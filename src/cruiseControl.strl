% Module which manages the state of the cruise control system to follow the
% behavioural requirements.
module StateMachine:
    % Constants defined in CruiseControl.h
    constant SPEED_MIN : float, SPEED_MAX : float, PEDALS_MIN : float;
    constant OFF : integer, ON : integer, STDBY : integer, DISABLE : integer; % In CruiseStates enum

    % Interface variables
    input On1, Off1, Resume1, Accel1 : float, Brake1: float, Speed1 : float;
    output CruiseState1 : integer;

    var state := OFF : integer in
        loop
            % Emit current state
            emit CruiseState1(state);
            pause;
            
            % Calculate next state
            trap TState in
                if state = OFF then
                    % Go on when the on button is pressed
                    present On1 then
                        state := ON;
                        exit TState;
                    end present;
                elsif state = ON then
                    % Go off when the off button is pressed
                    present Off1 then
                        state := OFF;
                        exit TState;
                    end present;

                    % Go standby when the brake is pressed
                    if ?Brake1 > PEDALS_MIN then
                        state := STDBY;
                    % Disable when accelerator pressed or outside of speed limits
                    elsif ?Accel1 > PEDALS_MIN or ?Speed1 < SPEED_MIN or ?Speed1 > SPEED_MAX then
                        state := DISABLE;
                    end if;
                elsif state = STDBY then
                    % Go off when the off button is pressed
                    present Off1 then
                        state := OFF;
                        exit TState;
                    end present;

                    % Exit standby when the resume button is pressed
                    present Resume1 then
                        % Disable when accelerator pressed or outside of speed limits, otherwise go on
                        if ?Accel1 > PEDALS_MIN or ?Speed1 < SPEED_MIN or ?Speed1 > SPEED_MAX then
                            state := DISABLE;
                        else
                            state := ON;
                        end if;
                    end present;
                elsif state = DISABLE then
                    % Go off when the off button is pressed
                    present Off1 then
                        state := OFF;
                        exit TState;
                    end present;

                    % Go standby when the brake is pressed
                    if ?Brake1 > PEDALS_MIN then
                        state := STDBY;
                    % Go on when accelerator not pressed and within speed limits
                    elsif ?Accel1 <= PEDALS_MIN and ?Speed1 >= SPEED_MIN and ?Speed1 <= SPEED_MAX then
                        state := ON;
                    end if;
                end if;
            end trap
        end loop
    end var
end module

module CarDrivingControl:
	input cdc_CruiseState : integer, cdc_CruiseSpeed : float, cdc_Speed : float, cdc_Accel : float;
	output cdc_ThrottleCmd : float;

	function regulateThrottle(integer, float, float) : float;
	
	var regulate := false : boolean in
	loop
		present(cdc_CruiseState) then
			if (?cdc_CruiseState = 2) then
				regulate := true;
			else
				regulate := false;
			end if;
		end present;

		if regulate then
			if (?cdc_CruiseState = 1 and pre(?cdc_CruiseState) = 0) then
				emit cdc_ThrottleCmd(regulateThrottle(1, ?cdc_CruiseSpeed, ?cdc_Speed));
			else 
				emit cdc_ThrottleCmd(regulateThrottle(0, ?cdc_CruiseSpeed, ?cdc_Speed));
			end if;
		else
			emit cdc_ThrottleCmd(?cdc_Accel);
		end if;

		pause;
	end loop
	end var
end module

% Module which manages the cruise speed.
module CruiseSpeedManagement:
	constant SPEED_MIN : float, SPEED_MAX : float, SPEED_INC : float;
	input cruiseManageSet, cruiseManageQuickAccel, cruiseManageQuickDecel;
	input cruiseManageState : integer;
	input cruiseManageSpeed : float;
	
	output cruiseManageCruiseSpeed : float;
	
	% temporary speed variable
	var temp_Speed := 0.0f : float in
		loop
		
			emit cruiseManageCruiseSpeed(temp_Speed);
			pause;
			
			trap cruiseManage_T in
				
				%Cruise control turned on
				if (pre(?cruiseManageState) = 1 and ?cruiseManageState = 2) then
					if ?cruiseManageSpeed > SPEED_MAX then
						temp_Speed := SPEED_MAX;
						exit cruiseManage_T;
						
					elsif ?cruiseManageSpeed < SPEED_MIN then
						temp_Speed := SPEED_MIN;
						exit cruiseManage_T;
						
					else
						temp_Speed := ?cruiseManageSpeed;
						exit cruiseManage_T;
					end if;
				end if;
				
				% Cruise control is on
				present cruiseManageSet then
					if ?cruiseManageSpeed > SPEED_MAX then
						temp_Speed := SPEED_MAX;
						exit cruiseManage_T;
						
					elsif ?cruiseManageSpeed < SPEED_MIN then
						temp_Speed := SPEED_MIN;
						exit cruiseManage_T;
						
					else
						temp_Speed := ?cruiseManageSpeed;
						exit cruiseManage_T;
						
					end if;
				end present;
				
				% Quick acceleration
				present pre(cruiseManageQuickAccel) then
					if (temp_Speed > (SPEED_MAX - SPEED_INC)) then
						 temp_Speed := SPEED_MAX;
						 exit cruiseManage_T;
						 
					else
						temp_Speed := temp_Speed + SPEED_INC;
						exit cruiseManage_T;
						
					end if;
				end present;
				
				%Quick Deceleration
				present pre(cruiseManageQuickDecel) then
					if (temp_Speed < (SPEED_MIN + SPEED_INC)) then
						temp_Speed := SPEED_MIN;
						exit cruiseManage_T;
						
					else
						temp_Speed := temp_Speed - SPEED_INC;
						exit cruiseManage_T;
						
					end if;
				end present;
				
				%Cruise control is off
				if ?cruiseManageState = 1 then
					temp_Speed := 0.0f;
					exit cruiseManage_T;
		 			
				end if;
				
			end trap;
		end loop;
	end var;
						
end module

% Top level module for the cruise control system that runs three modules in
% parallel.
module CruiseControl:
    % Interface variables
    input On, Off, Resume, Set, QuickDecel, QuickAccel, Accel : float, Brake: float, Speed : float;
    output CruiseSpeed : float, ThrottleCmd : float, CruiseState : integer;

    % Run modules
    signal state: integer in
        loop
            present state then
                emit CruiseState(?state);
            end present;
            pause
        end loop
        ||
        run StateMachine[ signal On/On1;
                          signal Off/Off1;
                          signal Resume/Resume1;
                          signal Accel/Accel1;
                          signal Brake/Brake1;
                          signal Speed/Speed1;
                          signal state/CruiseState1 ];
        ||
        run CarDrivingControl[
            signal CruiseState/cdc_CruiseState;
            signal CruiseSpeed/cdc_CruiseSpeed;
            signal Speed/cdc_Speed;
            signal Accel/cdc_Accel;
            signal ThrottleCmd/cdc_ThrottleCmd];
        ||
        run CruiseSpeedManagement[ 	signal Set/cruiseManageSet;
									signal Speed/cruiseManageSpeed;
									signal state/cruiseManageState;
									signal QuickAccel/cruiseManageQuickAccel;
									signal QuickDecel/cruiseManageQuickDecel;
									signal CruiseSpeed/cruiseManageCruiseSpeed];
    end signal
end module